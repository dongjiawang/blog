
---
layout: post

title: 面试准备
 
date: 2021-11-13 12:00:00

categories: ["充电"]

tags: 

mathjax: true

---


#  C 语言相关

## static 有什么用途

> 在 C 语言中，static 主要定义全局静态变量，定义局部静态变量，定义静态函数。static 属于静态变量，使用它修饰的变量的生命周期是整个源程序。
>
> 1. 在函数体内的 static 变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
> 2. 在模块内的 static 全局变量可以被模块内所有的函数访问，但不能被模块外其他函数访问；
> 3. 在模块内的 static 函数只被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内。

## 说一下对 C 语言指针的理解

> 1. 指针就是内存的地址，是 C 语言中广泛使用的一个数据类型，运用指针编程是 C 语言最主要的风格之一。
> 2. C 语言允许用一个变量来存放指针，这种变量称为指针变量。利用指针变量可以表示各种数据结构；能很方便的使用数组和字符串；从而编出精炼而高效的程序。

## C 语言里的顺序链表如何实现？

> 定义几个结构体，每个结构体里面包含两个成员，一个整形变量，一个指针变量。让一个结构体里的指针变量指向另一个结构体的地址，而另一个结构体里的指针变量又指向另一个结构体的地址，从而形成一个顺序链表。

## C 语言里的循环链表如何实现？

> 定义几个结构体，每个结构体里面包含两个成员，一个整形变量，一个指针变量。让一个结构体里的指针变量指向另一个结构体的地址，而另一个结构体里的指针变量又指向另一个结构体地址。然后让最后一个结构体里的指针变量指向开始那个结构体的地址，从而形成一个循环链表。C 语言里 typedef 与 define 有什么区别？

> #define 是在预编译时处理，它只能做简单的字符串替换；
>
> typedef 是在编译时处理，它是给已有类型起别名。

## 写一个标准宏 MIN，这个宏输入两个参数并返回较小的一个

```c
#define MIN(X,Y) ((X) > (Y) ? (Y) : (X))

// 使用三目运算符
// define 只会是纯替换作用，所以 X， Y 均需要加括号，防止 X， Y 为表达式的情况
```

## 什么是常量指针和指针常量？

> 常量指针：指向常量的指针，指向的内容不能被改变，可以通过指针修改指向的内容；
>
> 指针常量：指针本身是常量，指向的地址不可改变，但是地址里的内容可以通过指针改变。



# Objective-C 语言相关

## 基础语法

### 属性关键字 strong、weak、assign、readwrite、readonly、copy、nonatomic 各有什么作用？

> 1. strong：表示指向并拥有该对象。其修饰的对象引用计数会 + 1，该对象的引用计数不为 0，就不会被销毁，强行将其置为 nil，也可以销毁。
> 2. weak：表示指向但不拥有该对象，其修饰的对象引用计数不会增加，无需手动设置，该对象会自行在内存中被销毁。
> 3. assign：主要用于修改基本数据类型。
> 4. weak一般用来修饰对象，assign一般用来修饰基本数据类型，因为 assign 修饰的对象被释放后，指针地址依然存在，造成野指针，在堆上容易造成崩溃，而栈上的内存系统会自动处理。
> 5. readwrite： 可读可写属性，需要生成 getter、setter 方法
> 6. readonly：只读属性。只会生成 getter 方法
> 7. copy：与 strong 类型，不同之处是 strong 的复制是多个指针指向同一个地址，而 copy 的复制每次会在内存中复制一份对象，指针指向不同地址。copy 一般用在修饰对应可变类型的不可变对象上，如：NSString、NSArray、NSDictionary。
> 8. nonatomic：修饰的对象不保证 setter 和 getter 的完整性，所以当多个线程访问它时，可能会返回未初始化的对象，正因为如此，nonatomic 比 atomic 的速度快，但是线程是不安全的。
> 9. atomatic：修饰的对象会保证 setter 和 getter 的完整行，任何线程访问它都可以得到一个完整的初始化后的对象，因为要保证操作完成，所以速度比较慢。不是绝对的线程安全，要想线程绝对安全，需要用 @synchronized

### copy 与 mutableCopy 方法

> 1. copy 返回的都是不可变对象
> 2. mutableCopy 返回的是可变对象
> 3. 对不可变对象进行 copy 操作是指针复制，mutableCopy 是内容复制
> 4. 对可变对象进行 copy 和 mutablecopy 都是内容复制

### @property (nonatomic, copy) NSMutableArray *arr; 这个写法有什么问题？

> 添加、删除，修改数组元素时会崩溃。
>
> copy 返回的是一个不可变对象

### #import 和 #include 有什么区别？@class 呢？#import<> 跟 #import""有什么区别？

> 1. #import 是 OC 导入头文件的关键字，#include 是 C/C++导入头文件的关键字；使用 #import 头文件只会导入一次，不会重复导入
> 2. @class 是告诉编译器某个类的声明，当执行时才会去查看类的实现文件，可以解决头文件的相互包含
> 3. #import<> 用来包含系统的头文件，#import"" 用来包含用户头文件

### 描述下 synthesize 与 dynamic 的作用

> 1. 如果 @synthesize 和 @dynamic 都没写，默认是 @synthesize var = _var;
> 2. @synthesize 的语义是如果没有手动实现 setter 方法和 getter 方法，那么编译器会自动加上这两个方法；
> 3. @dynamic 是告诉编译器，属性的 setter 和 getter 方法由用户自己实现，不自动生成。（编译的时候不会报错，但是当程序运行到 instance.var = someVar 时，由于缺少setter 方法，会导致崩溃；或者 调用到 getter 方法时会崩溃）

### 类变量的 @public、@protected、@private、@package 各有什么含义

> * @public 任何地方都可以访问
> * @protected 该类和子类中访问
> * @private 只能在本类中访问
> * @package 只能在本包内使用

### 分类、类扩展和继承在实现中有何区别？

> 1. 分类有名字，类扩展没有分类名字，是一种特殊分类
> 2. 分类只能扩展方法，类扩展可以扩展属性、成员和方法
> 3. 继承可以增加、修改或者删除方法，可以增加属性

> 正常情况下，在 Category 中添加属性会报错，提示找不到 getter 和 setter方法，因为 category 不会自动生成这两个方法。可以引入运行时头文件，并配合关联对象的方法来实现，主要涉及两个函数是 objc_getAssociatedObject 和 objc_setAssociatedObject。

### OC 的类可以多重继承吗？可以实现多个接口吗？重写一个类时用继承好还是分类好？

> 不可以多重继承；
>
> 可以实现多个接口，通过实现多个接口可以完成类似多重继承的效果；
>
> 用分类去重写类的方法，仅对本分类有效，不会影响到其他的类与原有类的关系。

### 常见的 OC 数据类型有哪些？和 C 的基本数据类型有什么区别？如 NSInteger 和 int

> OC 的数据类型有 NSString、NSNumber、NSArray、NSMutableArray、NSData 等，这些都是 class。创建后都是 对象。
>
> C 语言的基本数据类型 int ，只是一定字节的内存空间，用于存放数值；NSInteger 时OC 的基本数据类型，并不是 NSNumber 的子类，NSInteger 是基本数据类型 int 或者 long 的别名，会根据系统是 32 位还是 64 位来决定本身是 int 还是 long。

### 说一下深拷贝与浅拷贝的区别

> 深拷贝：即会复制对象的指针也会复制对象属性的地址；
>
> 浅拷贝：只复制对象的指针，不会复制对象的属性的地址。

### 下面的代码输出什么？

```objc
@implementation Son : Father
- (id)init {
   if (self = [super init]) {
       NSLog(@"%@", NSStringFromClass([self class])); // Son
       NSLog(@"%@", NSStringFromClass([super class])); // Son
   }
   return self;
}
@end
```

> 解析：
>
> * self 是类的隐藏参数，指向当前调用方法的这个类的实例
> * super 本质是一个编译器标志符，和 self 指向同一个消息接收者
> * super 会告诉编译器，调用这个 class 方法时，要去父类方法，而不是本类里
> * 上面的例子中，接收消息的对象都是当前 Son *obj 这个对象

## block

### 描述一下对 block 的理解，它的作用有哪些？

> block 类似一个匿名的函数代码块，此代码块可以作为参数传递对象或方法，也可以作为方法的返回值；
>
> block 可以实现两个类之间的信息传递，并且 block 对局部变量是只读的，如果要修改，需要对变量加上 `__block`进行修饰
>
> block 是获取其他函数局部变量的匿名函数，功能是保存代码片段，预先准备好代码，在需要的时候执行。

> 作用是在两个类之间传递信息，或者对代码封装作为参数进行传递，或者作为方法返回值；
>
> 利用 block 实现 delegate。

### 使用 block 会产生内存泄漏吗？怎么解决？

> 当在 block 中之间调用局部对象或者当前对象 self 的属性或方法时，局部对象或者当前对象就会隐性的 retain 一次，导致相互引用；
>
> 可以加`__block`或者使用完之后立即释放 block（即 self.block = nil），防止内存泄漏。

### 一个 int 变量被 __block 修饰与否的区别

> * 没有修饰，被 block 捕获，是值拷贝
> * 修饰后，会生成一个结构体，复制 int 的引用地址，达到修改数据

### block 修改 NSMutableArray 是否需要 __block 关键字

> 如果修改 NSMutableArray 的存储内容，不需要加
>
> 如果修改 NSMutableArray 本身，需要加

### 什么情况下编译器会自动将栈上的 block 拷贝到堆内存？

> 1. block 作为函数的返回值
> 2. 将 block 赋值给附有 __strong 修饰符 id 类型的类或者 block 类型的成员变量时
> 3. 方法中含有 useingBlock 的 cocoa 框架方法或者 GCD 的 API 中传递 block 时
> 4. 调用 block 的 copy 函数时

## 通知、代理

> 通知是一对多的关系，当一个类需要跟多个类进行信息传递的时候，一般都是用消息通知；通知是同步的，使用时必须先注册并绑定接收通知的方法，消息中心创建消息内容，然后发送通知；不在监听时，移除监听通知对象

> delegate 是类与类之间信息传递的一种方式，使用 delegate 时，必须先声明协议，确认协议并实现协议中声明的方法，添加要委托的对象。
>
> 支持一对多，可以把 delegate 改成数组保存多个对象，调用时，取出每一个对象进行信息传递。

### 多次添加同一个通知会是什么结果？多次移除呢？

> 多次添加同一个通知，会导致发送一次通知时，响应多次。
>
> 多次移除通知不会产生 crash。

## KVC、KVO

### KVO 与 KVC 的区别

> 1. KVC 是键值编码，通过字符串的名字来访问类属性，而不是通过调用 Setter、Getter 方法。即使这个属性没有 Set 和 Get 方法，也能访问；
> 2. KVO 是键值观察，指定观察的对象的属性被修改后，KVO 会自动通知相应的观察者，用完后需要在 dealloc 方法中移除观察者。ARC 中也可以调用 dealloc，只不过不能调用 [super dealloc]。

### KVC 的底层实现

> 当通过 KVC 调用对象时，比如：[self valueForKey:"someKey"]
>
> 1. 检查是否存在相应的 key 的 set 方法，如果存在就调用 set 方法
> 2. 如果不存在 set 方法，会查找与 key 相同名称且带下划线的成员变量；如果有，直接给成员变量赋值
> 3. 如果没有找到带下划线的 key，会查找是否有相同名称的属性 key，如果有，直接赋值
> 4. 如果还是没有找到，则调用 valueForUndefinedKey： 和 setValue：forUndefinedKey 方法
> 5. 如果以上方法都抛出异常，可以根据需要重写它们



# swift 语言相关

## swift 是面向对象还是函数式编程语言？

> swift 既是面向对象的编程语言，又是函数式编程语言。
>
> 面向对象：支持类的封装、继承和多态；
>
> 函数式：支持 map、filter、flatmap 这类去除中间状态、数学函数式的方法，更加强调运算结果而不是中间过程。

## swift 中 struct 和 class 有什么区别

> struct 是值引用，存放于栈区；无法继承；
>
> class 是类型引用，存放于堆区；可以继承。

> class 如下功能是 struct 没有的：
>
> * 可以继承
> * 类型转换可以再运行时检查和解释一个实例的类型
> * 可以用 deinit 来释放资源
> * 一个类可以被多次引用。

> struct 的优势：
>
> * 结构较小，适用于复制操作，相比一个 class 的实例被多次引用，struct 更加安全
> * 无需担心内存泄漏或者多线程冲突

## 什么是可选型(optional)

> 可选型是为了表达当一个变量值为空的情况。当一个变量值为空时，他就是一个 nil。在 swift 中无论变量是引用类型还是值类型，都可以是可选型变量。

> 在 OC 中没有明确提出可选型的概念，然而其引用类型却可以为 nil，以此来标示其变量值为空的情况。

## 什么是泛型(generics)

> 泛型主要是为增加代码的灵活性而生，它可以使对应的代码满足任意类型的变量或者方法。

## 说明并比较关键词：Open、Public、Internal、File-private 和 Provate

> 它们遵循的基本原则是：高级别的变量不允许被定义为低级别变量的成员变量。比如：一个 Private 的 class 中不能含有 Public 的 string 值。反之，低级别的变量却可以定义在高级别的变量中，比如：Public 的 class 中可以含有 Private 的 Int 值。
>
> * Open：具备最高访问权限。其修饰的类和方法可以在任意的 Module 中被访问和重写。
> * Public：权限仅次于 Open。与 Open 唯一的区别在于，它修饰的对象可以在任意 Module 中访问，但是不能重写。
> * Internal：默认权限。表示只能在当前定义的 Module 中访问和重写。可以被一个 Module 中的多个文件访问。
> * File-private：修饰的对象只能在当前文件中使用。
> * Private：最低级别的访问权限，修饰的对象只能在定义的作用域内使用。

## 如何理解 swift 中的 copy-on-write

> 当值类型在复制时，复制的对象和原对象实际上在内存中指向同一个对象。当且仅当修改复制后的对象时，才会在内存中重新创建一个新的对象。
>
> 因此内存使用更加高效。

## 什么是属性观察(Property Observer)

> 属性观察是指在当前类型内对特定的属性进行监听，并做出响应的行为，属性观察是 swift 的特性，具体有两种：willSet 和 didSet。
>
> 初始化方法对属性的设置，以及在 willSet 和 didSet 中对属性的再次设定，都不会触发调用属性观察。

## swift 与 OC 有什么区别

<img src="https://pic1.zhimg.com/80/v2-dd0f064fd08d07b20df0fda0d43cf2a4_1440w.jpg" alt="img" style="zoom:70%;" />





# 内存管理

## 基本原理

### 说一下对 OC 内存管理的理解

> 2. ARC：是 OC 的内存管理机制，简单的说，就是代码中自动加入了 retain/release，原先需要手动添加来处理内存管理的引用计数的代码可以自动地由编译器完成。
> 2. 在 ARC 情况下，任何强指针（strong、retain）指向的对象就会被销毁；任何弱指针指向的对象不会被销毁；默认情况下对象都是强指针类型。
> 3. 自动释放池是 OC 的一种内存自动回收机制，可以将一些临时变量通过自动释放池来回收统一释放；内存池 autoreleasepool 是用于管理那些被声明为 autorelease 的对象，系统中有成千上万个内存池，系统内存不足时，系统会从栈中取最顶层的池子把引用计数为 0 的对象释放掉，收回内存给当前应用程序使用。自动释放池本身销毁时，池子里所有的对象都会做一次 release 操作。在使用 block 时，一定注意不能在 block 里面直接对对象进行操作，而是需要使用`__block`或者`__weak`进行修饰，避免循环引用，造成内存泄漏。

### 操作系统内存布局，各分为什么区？

> * 栈区：由系统区管理，地址从高到低分配，先进后出。会存一些局部变量，函数跳转时现场保护，这些都是系统处理，所以大量的局部变量、深递归、函数循环调用都可能耗尽栈内存而造成程序崩溃。
> * 堆区：需要开发人员管理内存，alloc 申请内存，release 释放内存。创建的对象也都放在这里，地址是从低到高分配。堆是所有程序共享的内存，当 N 个内存得不到释放，堆区会被挤爆崩溃。
> * 全局区/静态区：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。
> * 常量区：常量字符串存放，还有 const 常量。
> * 代码区：存放 App 代码，App 程序会拷贝到这里。

### 堆和栈的区别

> 栈由编译器自动管理，无需手动控制；堆的释放需要开发人员控制，容易产生内存泄漏；
>
> 栈的存储顺序是由高地址向低地址，是一块连续的内存区域，能获得栈的空间较小，栈有两种分配方式：静态分配和动态分配；
>
> 堆的存储顺序是由低地址向高地址，是不连续的内存区域，堆获得的空间比较灵活也比较大，堆是动态分配和回收内存，没有静态分配的堆。

### 为什么要分堆和栈？不分堆和栈行吗？

> 1. 从软件设计角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。这种隔离、模块化的思想在软件设计方方面面都有体现；
> 2. 堆与栈的分离，使得堆中的内容可以被多个栈共享，这种共享提供了一种有效的数据交互方式，堆中的共享常量和缓存可以被所有栈访问，节省了空间；
> 3. 栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制栈的存储内容的能力。堆中的对象可以根据需要动态增长，因此堆和栈的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

### 为什么栈上面效率高

> 对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，是程序效率低。
>
> 对于栈来讲，遵循先进后出的队列，队列是一一对应的，不会先出一个内存块从栈中弹出。

### 僵尸对象、野指针、空指针分别指什么？有什么区别？

> * 僵尸对象：堆中已经被释放的对象（retainCount == 0）
> * 野指针：不是 NULL 指针，是指向一个非法的或者已经销毁的内存指针；
> * 空指针：指针赋值为 空
>   * 没有存储任何内存地址的指针成为空指针 NULL
>   * 空指针是被赋值为 0 的指针，在没有被具体初始化之前，其值为 0。

### 什么是虚拟内存、共享内存、物理内存

> * 虚拟内存：当我们向系统申请内存时，系统并不会给你返回物理内存的地址，而是给你一个虚拟内存地址。每个进程都拥有相同大小的虚拟地址空间，对于 32 位的进程，可以拥有 4GB 的虚拟内存，64 位进程，可达 18EB 。只有我们开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，从而让程序使用真实的物理内存。
>
>   系统会对虚拟内存和物理内存进行分页，虚拟内存到物理内存的映射都是以页为最小粒度。
>
>   虚拟内存是在物理内存上建立的一个逻辑地址空间，它向上(应用)提供了一个连续的逻辑地址空间，向下隐藏了物理内存的细节。
>
>   虚拟内存使得逻辑地址可以没有实际的物理地址，也可以让多个逻辑地址对应到一个物理地址。
>
>   虚拟内存被划分为一个个大小相同的 page，提高管理和读写效率，page 又分为只读和读写。
>
> * 共享内存指在多处理的计算机系统中，可以被不同的 CPU 访问的大容量内存。
>
> * 物理内存：真实的硬件设备。

### 描述下`__block`和`__weak`修饰符的区别

> `__block`不管是 ARC 还是 MRC 模式，都可以使用，可以修饰对象，还可以修饰基本数据类型，`__block`对象可以在 block 中重新被赋值；
>
> `__weak`只能在 ARC 模式下使用，只能修饰对象，不可以在 block 中重新赋值。

## 实际问题

### 对于基本数据类型，一般是存储到栈中的，有没有可能存在堆上，什么情况下存到堆上？

> 栈和堆都是同属一块内存，只不过一个是高地址往低地址存储，一个从低地址往高地址存储，它们并没有严格的界限。所以基本数据类型也是可以存储到堆上的。
>
> 当该基本类型变量被 `__block`捕获时，该变量连同 block 都会被 copy 到堆上。

### 对象分配到堆还是栈

> OC 的对象在内存中是以堆的方式分配空间，并且堆内存是由开发者释放，就是 release；
>
> 非 OC 对象一般放在栈里。

### 堆为什么默认是 4G，是什么决定的？机器上插 16G 的内存条，虚拟内存只有 4G，是不是浪费？

> 每个进程都拥有相同大小的虚拟地址空间，对于 32 位的进程，可以拥有 4GB 的虚拟内存。
>
> 系统可以运行很多的进程，当进程开始真正使用内存时，会映射到物理内存上。

### 对象的 isa 指针指向哪里

> instance 对象的 isa 指向 class 对象；
>
> class 对象的 isa 指向 meta-class 对象；
>
> meta-class 对象的isa 指向基类的 meta-class 对象。

### iOS 开发中什么情况下会有野指针？

> 1. 指针未初始化；
> 2. 指针变量在定义时不会自动初始化成空指针，而是随机一个值，可能指向任意空间，这就使该指针成为野指针。因此指针初始化时要么指向一个合理的地址，要么初始化为 NULL；
> 3. 在释放空间后，指针指向的内容被销毁，空间被释放，当时指针的值并未改变，仍然指向这块内存，这就使得该指针成为野指针，因此在调用 free 或者 delete 之后，应该将该指针置为 NULL；
> 4. 指针操作超过所指向变量的生存期；
> 5. 当指针指向的变量的声明周期已经结束时，如果指针仍然指向这块空间，就会使得该指针成为野指针，养成良好的编码习惯，避免发生这样的情况。

### 栈会溢出吗？什么情况下会溢出

> 1. 在函数内部定义的超大数组会导致栈溢出
> 2. 递归次数过多

### 一个 OC 对象如何进行内存布局(考虑有父类情况)

> 最前面是 isa 指针，父类的成员变量存放在子类成员变量之前，所有父类的成员变量和自己的成员变量都会存放在该对象所对应的存储空间中。
>
> 每个对象内部都有一个 isa 指针，指向他的类对象，类对象中放置着本对象的：对象方法列表、成员变量列表、属性列表。

### 一个 autorelease 对象在什么时候释放？

> 分两种情况：手动干预释放时机、系统自动去释放
>
> 手动干预释放：当前作用域大括号结束时释放
>
> 系统自动去释放：autorelease 对象在出了作用域之后，会在当前 runloop 结束时释放

### 引用计数为 0 的引用实例是立即回收吗？

> 对象的内存销毁分四个步骤：
>
> 1. 调用 release：引用计数变为 0
>    * 对象正在被销毁，生命周期即将结束
>    * 不能再有新的 `__weak`引用，否则将指向 nil
>    * 调用[self dealloc]
> 2. 子类调用 dealloc
>    * 继承关系中最底层的子类在调用 dealloc
>    * 如果是 MRC 代码，则会手动释放实例变量们
>    * 继承关系中每一层的父类在调用 dealloc
> 3. NSObject 调用 dealloc
>    * 只做一件事：调用 OC Runtime 中的 object_dispose() 方法
> 4. 调用 object_dispose()
>    * 为 C++ 的实例变量们调用 destructors
>    * 为 ARC 状态下的实例变量们调用 release
>    * 解除所有使用 runtime Associate 方法关联的对象
>    * 解除所有 __weak 引用
>    * 调用 free()

### 内存泄漏可能出现的几种原因

> 1. 第三方框架使用不当
> 2. block 循环引用
> 3. delegate 循环引用
> 4. NSTimer 循环引用
> 5. 非 OC 对象内存处理
> 6. 大次数的循环导致内存暴涨



# 多线程

## 基本定义

### 描述一下线程与进程的区别

> 1. 进程有独立的地址空间，一个进程崩溃后，在其保护模式先下不会对其他进程产生影响，而线程只是一个进程中的执行路径；
> 2. 线程有自己的堆栈，但线程直接没有单独的地址空间，一个线程死掉，就等于这个进程死掉，所以多进程程序比多线程程序健壮；
> 3. 进程切换时耗费资源较大，效率差一些，对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程而不是进程。

### 常用的多线程有哪些？有什么特点？

> 1. NSThread：轻量级多线程。需要开发者管理线程的生命周期、线程同步。
> 2. GCD：面向底层的 C 语言 API，简单易用，执行效率高，队列中执行的是由 block 构成的任务，代码更为易读；
> 3. NSOperationQueue：对 GCD 的封装，可以设置最大并发数、优先级、添加依赖关系，支持 KVO，可以监测 operation 的执行状态。

### 描述一下线程同步与异步的区别

> 线程同步是指当前有多个线程的话，必须等一个线程执行完成才能执行下一个线程，使用 @synchronized 加锁处理；异步线程是指一个线程去执行，它的下一个线程不同等待它执行完就可以开始执行。
>
> 异步主要是效率提高，同步线程主要解决线程安全问题。

## 实际应用

### 多线程在实际代码中的应用

> 1. 使用多线程进行网络请求
> 2. 多线程解析 JSON 数据
> 3. 多线程进行本地缓存
> 4. 异步处理数据

### 使用 GCD 加载多张图片后，如何把加载的图片融合到一张图片中

> 使用 group 开启多个异步线程加载图片，这些图片加载完成之后，在汇总通知中调用主线程，在主线程里开启图形上下文，在 drawinrect 方法中绘制加载饿图片，获取合成图片，关闭图形上下文。

### GCD 如何设置任务依赖

> 1. 使用串行队列
> 2. 在队列中添加 barrier 任务，控制执行顺序

### 多线程共享同一数据，如何防止错乱

> 1. @synchronized 对参数对象同步处理，保证临界区内的代码线程安全
> 2. 使用 NSLock 进行加锁处理，等线程执行结束后再进行解锁处理

### 多线程之间如何进行数据传递？有哪些注意事项？

> 1. -(void) perfromSelectOnMainThread: withObject: waitUntilDone 
>
>    注意事项：waitUntilDone 是 YES 的话，子线程结束后会阻塞主线程，然后走要执行的方法；如果是 NO。不会阻塞线程
>
> 2. 使用本地存储方式。或者使用 block
>
>    注意事项： 使用 block 时，注意循环引用和 `__block`修饰符的使用；多线程共享数据，防止错乱。

### iOS 并发编程中的三大问题

> * 竞态条件：指两个或两个以上线程对共享的数据进行读写操作时，最终的数据结果不确定的情况。
> * 优先倒置：指低优先级的任务会因为各种原因先于高优先级的任务执行，比如：低优先级的线程可以锁上某种高优先级线程需要的资源，从而迫使高优先级的线程等待低优先级的线程。
> * 死锁问题：指两个或以上的线程，它们之间相互等待彼此停止执行，以获取某种资源，但是没有一方会提前退出的情况。

### 比较 GCD 中的方法：dispathc_async,dispatch_after,dispatch_once,dispatch_group

> * dispathc_async:用于对某个线程进行异步操作。
> * dispatch_after： 一般用于线程的延时操作
> * dispatch_once：用于确保单例的线程安全，表示修饰的区域只会访问一次
> * dispatch_group：一般用于多任务同步，当多个任务关联到同一个群组后，所有任务在执行完成后，在执行一个统一的后续工作。

### dispatch_barrier_async(栅栏函数)的作用

> 1. 在它前面的任务执行结束后它才执行，它后面的任务需要等它执行完成后才会开始执行
> 2. 避免数据竞争

```objc
// 1.创建并发队列
dispatch_queue_t queue = dispatch_queue_create("myQueue", DISPATCH_QUEUE_CONCURRENT);
// 2.向队列中添加任务
dispatch_async(queue, ^{  // 1.2是并行的
    NSLog(@"任务1, %@",[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@"任务2, %@",[NSThread currentThread]);
});
 dispatch_barrier_async(queue, ^{
    NSLog(@"任务 barrier, %@", [NSThread currentThread]);
});
 dispatch_async(queue, ^{   // 这两个是同时执行的
    NSLog(@"任务3, %@",[NSThread currentThread]);
});
dispatch_async(queue, ^{
    NSLog(@"任务4, %@",[NSThread currentThread]);
});
 // 输出结果: 任务1 任务2 ——》 任务 barrier ——》任务3 任务4
 // 其中的任务1与任务2，任务3与任务4 由于是并行处理先后顺序不定。
```

### 以下代码运行结果如何

```objc
- (void)viewDidLoad {
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
// 只输出：1。（主线程死锁）
```

> //死锁原因
> //1:dispatch_sync在等待block语句执行完成，而block语句需要在主线程里执行，所以dispatch_sync如果在主线程调用就会造成死锁
> //2:dispatch_sync是同步的，本身就会阻塞当前线程，也即主线程。而又往主线程里塞进去一个block，所以就会发生死锁。



# 网络

## 描述一下对 get 请求与 post 请求的理解

> get 是向服务器发送、索取数据的一种请求，get 的请求参数会跟在 url 后进行传递，以 ? 分割 url 和传输数据，参数之间以 & 相连，安全性不高，get 请求的数据大小有限制，一般不超过 255 个字节；
>
> post 是向服务器提交数据，post 请求会把消息放到 body 中，安全性较高，且没有限制提交的数据。

## 描述一下对 TCP、UDP、HTTP 的理解

> 1. TCP 为传输控制层协议，为面向连接、可靠的、点到点的通信
> 2. UDP 为用户数据报协议，非连接的不可靠的点到多点的通信
> 3. TCP 侧重可靠传输，UDP 侧重快速传输
> 4. HTTP 是基于 TCP 的连接，是应用层协议

## 描述一下 TCP/IP 建立通信的过程

> 1. 第一次握手：客户端发送请求到服务器，并进入 SYN_SEND 状态，等待服务器确认；
> 2. 第二次握手：服务器收到客户端连接请求，向客户端发送允许连接应答，服务器进入 SYN_RECV 状态；
> 3. 第三次握手：客户端收到服务器允许连接的应答，向服务器发送确认，客户端和服务器进入通信状态，完成三次握手。

## 描述 HTTP 与 HTTPS 的区别

> http 是超文本传输协议，信息是明文传输，https 是具有安全性的 ssl 加密传输协议。
>
> http 连接很简单，是无状态的；https 是由 SSL+HTTP 构建的可进行加密传输、身份认证的网络协议

## HTTPS 加密原理

> 1. 服务端用非对称加密（RSA）生成公钥和私钥；
> 2. 服务端把公钥发送给客户端，服务端保存私钥；
> 3. 客户端拿到公钥后，生成一个密钥(这个密钥就是将来客户端和服务端用来通信的钥匙)，客户端用公钥对密钥进行加密，发送给服务器；
> 4. 服务器拿到客户端发来的加密密钥后，使用私钥解密，到此双方都获得了通信的钥匙。

## 在一个 HTTPS 连接的网站中，输入账号和密码并单击登录按钮后，到服务器返回这个请求前，这期间经历了什么

> 1. 客户端打包请求：包括 URL、端口、账号密码等，这个请求应该包含 3 个方面：网络地址、协议、资源路径。
> 2. 服务端接收请求。
> 3. 服务端返回数字证书。
> 4. 客户端生成加密信息
> 5. 客户端发送加密信息
> 6. 服务端解锁加密信息
> 7. 服务端向客户端返回信息
> 8. 客户端解锁返回信息

## 说明并比较：URLSessionTask、URLSessionDataTask、URLSessionUploadTask、URLSessionDownloadTask

> * URLSessionTask: 一个抽象类，通过实现它，可以实例化任意网络传输任务，比如：请求、上传、下载
> * URLSessionDataTask：负责 HTTP GET 请求，是 URLSessionTask 的具体实现，一般用于从服务端获取数据，并存放在内存中。
> * URLSessionUploadTask：负责 HTTP POST/PUT 请求，继承与URLSessionDataTask，一般用于上传数据
> * URLSessionDownloadTask：负责下载数据，是 URLSessionTask 的具体实现，一般将下载数据保存在一个临时文件中。

## 说一说 session 和 cookie

> * session 是服务端用来认证、追踪用户的数据结构，通过判断客户端传来的信息确定用户。确定用户的唯一标志是客户端传来的 sessionID
> * cookie 是客户端用来保存用户信息的机制。初次会话时，HTTP 协议会在 cookie 里记录一个 sessionID，之后每次会话时把 sessionID 发给服务器
> * session 一般用于用户验证。默认储存在服务器
> * 若是客户端禁用了 cookie，则客户端会用 URL 重写技术，即会话时在 URL 的末尾加上 session ID，并发送给服务端。





# 本地储存

## 常用的本地储存有什么？各有什么特点？

> 1. 文件写入：只能存储系统的数据类型，永久保存在磁盘中
> 2. 归档：采用归档形式保存数据，该数据对象需要遵守 NSCoding 协议，并且该对象对应的类必须提供encodeWithCoder：，initWithCoder 方法，然后创建沙盒，设置归档路径，使用 NSkeyedArchiver 序列化进行编码，使用 NSKeyedUnarchiver 反序列化进行解码
> 3. NSUserDefauls：主要用来保存应用程序的设置和属性，用户再次打开程序或开机后这些数据仍然存在
> 4. 数据库：SQLite、CoreData

## 描述一下对 CoreData 的理解

> CoreData 是一个模型层的技术，也是一种持久化技术，它能将模型对象的状态持久化到磁盘中，它可以对数据进行增删改查；创建工程时，需要勾选 CoreData 选项，创建模型文件，可以在模型文件里添加实体对象；然后新建一个 NSManagedObject cubclass 文件；工程创建完成后，它会在 AppDelegate.h 中自动生成三个属性；然后在需要使用的类里面添加 CoreData 头文件，再使用它的属性，就可以对数据进行增删改查操作。

## CoreData 如何进行数据筛选？说出查询 age 字段在 18 岁到 28 岁的筛选条件

> ```objc
> NSPredicate *predicate = [NSPredicate predicateWithFormat:@"SELF.age BETWEED{18,28}"];
> ```

## 描述一下对系统数据库 sqlite 的理解

> sqlite 是轻量级嵌入式数据库，系统中内置了sqlite，可以创建表，执行 SQL 语句对数据进行增删改查操作，完成之后关闭数据库。

## 数据库中的事务是什么意思

> 事务就是访问并操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行。如果其中一个步骤出错就要撤销整个操作，回滚到进入事务之前的状态。

## iOS 的沙盒目录

> 1. Application：存放程序源文件
> 2. Documents：常用目录，iCloud备份目录，存放数据
> 3. Library：
>    * Caches：存放体积大又不需要备份的数据
>    * Preference：设置目录
> 4. tmp：存放临时文件，这个文件下的数据有可能随时被清除



# UI 相关

## CALayer 和 UIView 的区别

> 1. UIView 和 CALayer 都是在 UI 操作的对象。两者都是 NSObject 的子类，发生在 UIView 上的操作本质上也发生在对应的 CALayer 上。
> 2. UIView 是 CALayer用于交互的对象。UIView 是 UIResponder 的子类，其中提供了很多CALayer 所没有的交互上的接口，主要负责处理用户触发的各种操作。
> 3. CALayer 在图像和动画渲染上性能更好，因为 UIView 有冗余的交互接口，而且相比 CALayer，还有层级之分，CALayer 无需处理交互时进行渲染，可以节省大量时间。

## frame 和 bounds 有什么不同

> frame：该 view 在父 view 坐标系中的位置和大小
>
> bounds：该 view 在本身坐标系中的位置和大小

## layoutIfNeeded 和 setNeedsLayout 的区别

> * layoutIfNeeded: 如果有需要刷新的标记，立即调用 layoutSubViews 进行布局
> * setNeedsLayout：标记为需要重新布局，异步调用 layoutIfNeeded 刷新布局，在下一轮 runloop 刷新

## 说明并比较关键词： Safe Area、SafeAreaLayoutGuide 和 SafeAreaInsets

> * Safe Area: 指 App 合理显示内容的区域，不包括 status bar、navigation bar、tab bar 和 tool bar，在 iPhone X 中，一般是指扣除了顶部 status bar 和 底部 home indicator 的区域。
> * SafeAreaLayoutGuide：指 Safe Area 的区域范围和限制，在布局设置中，可以分别取得它的上下左右四个边界的位置进行相应的布局处理。
> * SafeAreaInset：限定了 Safe Area 区域与整个屏幕之间的布局关系，一般用上下左右 4 个值来获取 SafeArea 与屏幕边缘之间的距离。

## didMoveToSuperView、layoutSubviews、drawRect 都在什么时候调用？实际编码中用来做什么？

> didMoveToSuperView：当继承自 UIView 的子视图被贴到父视图时调用，可以在此方法中设置子视图自身的属性；
>
> 
>
> layoutSubviews：当添加到父视图或自己添加子视图时调用，当修改自己的 frame 或子视图的 frame 时也会调用，当自己调用 setNeedsLayout 方法时也会调用，父视图 UIScrollView 滚动时或者屏幕旋转时也会调用；可以在此方法中对子视图进行重新布局；
>
> 
>
> drawRect：贴到父视图时调用，设置它的 contentMode 属性值为 UIViewContentModeRedraw 时，每次更改 frame 时调用，直接调用 setNeedsDisplay 或 setNeedsDisplayRect 时也会调用；可以在此方法中绘制自己的内容。

## 说一下 UIScrollView 实现原理

> 在滚动过程中，其实是在修改圆点坐标。当手指触摸后，scrollView 会暂时拦截触摸事件，使用一个计时器，假如计时器到点后没有发生手指移动事件，那么 scrolView 发送 tracking events 到被点击的 subview。假如计时器到点前发生了移动事件，那么 scrollview 取消 tracking，自己发生滚动。

## UIScrollView 及其子类中 contentView、contentInset、contentSize 和 contentOffset 说明

> * contentView：显示内容的区域，一般情况下，用户对 UIScrollView 的操作都是在这 contentView 中进行的。
>
> * contentInset：指 contentView 与 UIScrollVIew 的边界。分别指 contentView 的四条边到 UIScrollView 的对应边的距离。
> * contentSize：指contentView 的大小，是整个 UIScrollView 的实际内容大小。
> * contentOffSet：当前 contentView 浏览位置左上角的点的坐标。是相对于整个 UIScrollView 左上角为原点而言，默认是 CGPointZero。

## 描述一下事件的响应者链

> 当前触发事件 - 根视图上的子视图 - 视图控制器上的根视图 - 视图控制器 - 窗口 - UIApplication 对象 - 丢弃

## CoreAnimation 和 CoreGraphic 的区别

> * CoreAnimation：核心动画，可以实现效果非常好的动画效果
>   * 支持 iOS、macOS
>   * 在后台执行动画，不会阻塞主线程
>   * 作用在 CALayer
>
> CoreGraphic：核心图形库，常用的 point、size、rect 等都定义在这个框架中，类名以 CG 开头饿都属于 CoreGraphic，提供的是 C 语言函数接口，支持 iOS、macOS。

> CoreAcimation 和 CoreGraphics 的关系：都是跨 iOS、macOS 平台，CoreAnimation 中大量使用到 CoreGraphics 中的类。

## UIView 动画与核心动画的区别

> 核心动画只作用在 layer
>
> 核心动画不会去修改 view 的真实位置

> 什么时候使用 UIView 动画
>
> 如果需要与用户交互就使用 UIView 动画

> 什么时候使用核心动画
>
> 1. 不需要与用户交互
> 2. 需要根据路径做动画时，使用核心动画
> 3. 做转场动画时需要使用核心动画

## 如何兼容不同的屏幕

> 1. 在代码中写一个宏，判断当前设备的屏幕尺寸，根据不同的尺寸，动态调整图片及视图的尺寸；
> 2. 使用 main.storyboard 中的 size class 属性对不同的屏幕尺寸进行开分类处理
> 3. 使用自动布局（masonry）

## 添加约束时，如果产生了警告和冲突，如何解决

> 1. 非运行的约束冲突，去掉冲突中的一个约束；
> 2. 运行时的约束冲突：通过阅读日志，在运行时动态修改约束冲突

## xib 与 storyboard 的区别

> xib 是轻量级，用来描述局部的 UI 界面，一个工程中可以有多个 xib 文件，主要用于视图，一个 xib 可以在不同的视图控制器中使用。
>
> storyboard 是重量级，用来描述整个软件的多个界面，并且能展示多个界面之间的跳转关系，主要用于视图控制器。多个 storyboard 之间可以关联使用。

## 如何实现视图变形

> 修改 view 的 transform 属性

## 高性能的给 UIImageView 增加圆角

> 使用图形上下文绘制

```objc
- (UIImage *)circleImage {
    // NO代表透明
    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0);
    // 获得上下文
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    // 添加一个圆
    CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
    CGContextAddEllipseInRect(ctx, rect);
    // 裁剪
    CGContextClip(ctx);
    // 将图片画上去
    [self drawInRect:rect];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    // 关闭上下文
    UIGraphicsEndImageContext();
    return image;
}
```

## transform 改变的是 frame 还是 bounds

> transform 的改变，会影响 frame，bounds 不会受到影响
>
> transform 时一个矩阵，使用矩阵乘法，对 view 的frame 进行变换



# RunLoop、Runtime、Method Swizzle

## Runloop

### 什么是 RunLoop

> 运行循环，内部就是 do-while 循环。在这个循环内部不断的处理各种任务。
>
> 一个线程对应一个 RunLoop，基本作用就是保持程序的持续运行，处理 app 中的各种事件。
>
> 节省 CPU 资源，提供程序性能。
>
> 
>
> RunLoop 通过 mode 来指定事件在运行循环中的优先级：
>
> * NSDefaultRunLoopMode：默认空闲状态
> * UITrackingRunLoopMode： scrollView 滑动时
> * UIInitializationRunLoopMode： 启动时
> * NSRunLoopCommonModes： mode 集合

### RunLoop 滑动中定时器失效的原因

> 滑动时，主线程的 RunLoop 会转到 UITrackingRunLoopMode，这时 Timer 就不会运行。
>
> 有两种解决方案：
>
> 1. 设置 NSTimer 运行于 NSRunLoopCommonModes
> 2. 在另外一个线程执行和处理 Timer 事件，然后主线程更新 UI

## Runtime

### 什么是 Runtime

> Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一。

### Runtime 的实现机制

> 1. 系统首先找到消息的接收对象，然后通过对象的 isa 找到它的类；
> 2. 在它的类中查找 method_list ，是否有 selector 方法；
> 3. 没有则查找父类的 method_list ；
> 4. 找到对应的 method，执行它的 IMP；
> 5. 转发 IMP 的 return 值。

### Runtime 的应用

> 1. 给分类增加属性；
> 2. 方法的添加和替换，KVO的实现；
> 3. 消息转发（热更新）；
> 4. 实现 NSCoding 的自动归档和自动解档；
> 5. 实现字典和模型的自动转换。

## Method Swizzle

### 什么是 Method Swizzle ？什么情况下会使用？

> 1. 在没有一个类的实现源码情况下，想改变其中一个方法的实现，除了继承它重写和借助类别重名之外，可以使用 Method Swizzle
> 2. Method Swizzle 指的是改变一个已存在的选择器对应的实现过程，OC 中方法的调用能够在运行时通过改变类的调度表中选择器到最终函数间的映射关系
> 3. 在 OC 中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是 selector 名称。利用 OC 的动态特性，可以实现在运行时偷换 selector 对应的方法实现
> 4. 可以利用 method_exchangeImplementations 来交换两个方法中的 IMP
> 5. 可以利用 class_replaceMethod 来修改类
> 6. 可以利用 method_setImplementation 来直接设置某个方法的 IMP

### _objc_msgForward 函数是做什么的？直接调用它将会发生什么？

> _objc_msgForward 是 IMP 类型，用于消息转发；
>
> 当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward 会尝试做消息转发。



# 设计模式

## 设计模式是什么？简要概述

> 设计模式是一种编码经验，用比较成熟的逻辑去处理某一种类型的事情；
>
> 1. MVC 模式：model、view、control，把模型、视图、控制器进行解耦；
> 2. MVVM 模式：在 MVC 的基础上增加 viewmodel 层，把模型、视图和业务逻辑进行解耦；
> 3. 单例模式：通过 static 关键字，声明全局变量，在整个进程运行期间只会被赋值一次；
> 4. 观察者模式： KVO 是典型的通知模式，观察某个属性的状态，状态发生变化时，通知观察者；
> 5. 委托模式：代理+协议的组合，实现 1 对 1 的方向传值操作；
> 6. 工厂模式： 通过一个类方法，批量的根据已有的模版生产对象。

## 比较 MVC 和 MVVM

> * 模型层几乎相同：模型层从理论上来说都是数据来源
> * 视图层在理论上都被设计为被动，但是实际上略有不同：在实际的开发中，MVC 的视图层和中间层高度耦合，几乎所有的操作都统一由 ViewController 包办。
> * 中间层的设计是两种架构的核心差异：从逻辑上讲，中间层的作用就是连接视图层和模型层。它用于处理交互、接收通知和完成数据更新。
>   * MVC 的中间层 Controller 持有视图和模型，主要起到组装和连接的作用，通过传递参数和实例变量来直接完成所有操作。
>   * MVVM 的中间层 viewModel 持有模型，在更新模型上与 MVC 相同。它独立于视图，视图拥有中间层，通过绑定属性自动更新。
> * MVC 的耦合度很高，维护和扩展成本最高，但是因为无须层级传递，所以代码总量较小
> * MVVM 的耦合度角度，比较容易实现高测试覆盖率。

## 什么是单例？及优缺点

> 单例就是一个类只被实例化一次，提供对唯一实例的受控访问

> 优点：一个类只被实例化一次，提供唯一的实例受控访问，节省系统资源，允许可变数目的实例
>
> 
>
> 缺点：一个类只有一个对象，可能造成责任过重，在一定程度上违背了单一职责的原则；单例模式中没有抽象层，因此单例扩展有很大困难；滥用单例模式将带来一些负面问题，比如：实例化对象长时间不被利用，系统会认为是垃圾而被回收，导致对象状态丢失。

## 创建单例有哪两种方式？

> 1. 创建一个全局静态实例并置为 nil；实现一个实例构造方法并同步处理，再判断上面声明的静态实例是否为 nil，如果是则新建并返回这个实例对象；
> 2. 使用 GCD 线程中只执行一次的方法来创建单例。

## 用伪代码写一个线程安全的单例模式

```objc
static id _instance;

+ (id)allocWithZone:(struct _NSZone *)zone {
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    _instance = [super allocWithZone:zone];
  });
  return _instance;
}

+ (instancetype)sharedData {
  static dispatch_once_t onceToken;
  dispatch_once(&onceToken, ^{
    _instance = [[self alloc] init];
  });
    return _instance;
}

- (id)copyWithZone:(NSZone *)zone {
  return _instance;
}
```



# 常用第三方库

## AFNetworking

> AFNetworking 主要是对 NSURLSession 的封装，主要有以下类：
>
> 1. AFHTTPSessionManager：内部封装是 NSURLSession，负责发送网络请求
> 2. AFNetworkReachabilityManager：实时监测网络状态的工具类
> 3. AFSecurityPolicy：网络安全的工具类，主要是针对 HTTPS 服务
> 4. AFURLRequestSerialization：序列化工具类
> 5. AFURLResponseSerializer：反序列化工具类
> 6. AFJSONResponseSerializer：JSON 解析器
> 7. AFHTTPResponseSerializer：万能解析器，解析 JSON 和 XMl 之外的数据类型，直接返回二进制数据，对服务器返回的数据部作品任何处理
> 8. AFXMLParserResponseSerializer：XML 解析器

## SDWebImage

> SDWebImage 中为 UIIMageView 提供了一个分类 UIImageView+WebCache，这个分类中有一个最常用的接口 sd_setimageWithURL:placeHolderImage:,会在真实图片出现前先显示占位图，当真实图片加载出来之后再替换占位图片
>
> 
>
> 加载图片的大致过程如下：
>
> 1. 首先在 SDWebImageCache 中寻找图片是否有对应的缓存，它会以 url 作为数据的索引现在内存中寻找是否有对应的缓存
> 2. 如果内存中未找到，会利用通过 MD5 处理过的 key 继续在磁盘中查询对应的数据，如果找到了，会把磁盘中的数据加载内存中，并将图片显示出来
> 3. 如果内存和磁盘中都没有找到，会向远程服务器发送请求，下载图片
> 4. 下载完成后的图片会加入缓存，并写入磁盘
> 5. 获取图片的过程在子线程中执行，获取图片后回到主线程显示图片

## 对 masonry 的理解

> masonry 是一个轻量级的布局框架，采用链式语法封装自动布局，使代码更为易读，只声明了方法，没有声明相应的属性，通过添加约束条件来确定视图的位置，主要包含点语法、小括号调用、连续访问三部分。

> 注意事项：
>
> 1. 使用 mas_makeConstraints方法的元素必须事先添加到父元素的中，例如[self.view addSubview:view];
> 2. masequalTo 和 equalTo 区别：masequalTo 比equalTo多了类型转换操作，一般来说，大多数时候两个方法都是 通用的，但是对于数值元素使用mas_equalTo。对于对象或是多个属性的处理，使用equalTo。特别是多个属性时，必须使用equalTo,例如 make.left.and.right.equalTo(self.view);
> 3. with和and,这两个方法其实没有做任何操作，方法只是返回对象本身，这这个方法的左右完全是为了方法写的时候的可读性 。



# 性能优化

## 解决 tableView 卡顿

> 1. 正确的复用 cell
> 2. 对于复杂视图可以采用懒加载来推迟创建时间，尽量减少视图层级
> 3. 提前计算并缓存高度(布局)
> 4. 异步绘制，在复杂的界面使用
> 5. 滑动时按需加载，在大量图片展示，网络加载时很管用
> 7. 尽量使所有的视图不透明化及圆角使用切圆操作
> 8. 不要动态的 add 或者 remove 子控件，可以通过 hidden 属性控制是否显示

## 影响启动速度的因素有哪些

> 1. main() 函数之前的耗时
>
>    动态库加载越多，启动越慢；
>
>    ObjC 类越多，启动越慢；
>
>    ObjC 的 +load 越多，启动越慢
>
>    C 的 constructor 函数越多，启动越慢；
>
>    C++ 的静态对象越多，启动越慢；
>
> 2. main() 函数之后的耗时
>    执行 main() 函数的耗时
>
>    执行 applicationWillFinishLaunching 的耗时
>
>    rootViewController 及其 childViewController 的加载

> 常用的优化启动速度的方案：
>
> * 减少动态库数量，动态库加载时间会减少，苹果官方推荐的是动态库不要多于 6 个
> * 减少 Objective-C 的类数量，例如合并或删除，可以加快动态链接，重定位所耗费的时间会减少
> * 使用 initialize 方法替换 load 方法，或是尽量将 load 方法中的代码延后调用，对象的初始化所耗费的时间会减少。

## Appdelegate 如何瘦身？

> 使用分类，针对不同的功能增加分类。

## 讲如何将一张内存极大的图片可以像地图一样的加载出来

> 把大图分成 N 片，利用多线程对图片进行渲染。
>
> 使用 CATiledLayer 将需要绘制的内容分割成许多小块，然后在多线程中按需异步绘制相应的部分。

## 二进制重排的核心依据是什么

> 修改链接顺序，减少启动时的缺页中断。



# 算法

## 替换 A 和 B 的值

```c
// 中间变量
void swap(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}
```

```c
// 加法
void swap(int a, int b) {
  a = a + b;
  b = a - b;
  a = a - b;
}
```

```c
// 异或
void swap(int a, int b) {
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
}
```

## 求最大公约数

```c
// 直接遍历
int maxCommonDivisor(int a, int b) {
  int max = 0;
  for(int i = 1; i <= b; i++) {
    if(a % i == 0 && b % i == 0) {
      max = i;
    }
  }
  return max;
}
```

```c
// 辗转相除
int maxCommonDivisor(int a, int b) {
  int r;
  while(a % b > 0) {
    r = a % b;
    a = b;
    b = r;
  }
  return b;
}
```

> 扩展：最小公倍数 = （a * b）/最大公约数

## 排序算法

### 冒泡排序

```c
// 两两比较，质量大的下沉，质量小的上浮；
// 外层循环用于控制排序次数，n 个数需要 n-1 次；
// 内层循环用于两两比较，每次找出最大的沉到底部。

for (i = 1; i < n; i++) {
  for (j = 0; j < n - i; j++) {
    if (ary[j] > ary[j+1]) {
      temp = ary[j];
      ary[j] = ary[j + 1];
      ary[j + 1] = temp;
    }
	}
}
```

### 选择排序

```c
// 每次获取一个关键字与它后面的数进行比较，找出最小的数与关键字进行交换；
// 外层循环用于获取关键字，同时控制循环次数，n 个数需要 n-1 次；
// 内存循环用于将关键字与它后面的数比较，找出最小的数与关键字进行交换。

/*
第一趟选择排序：从 n 个数中找出最小的数，将它与第一个数交换，结果最小的数被安置在第一个元素位置上；
第二趟选择排序：从 n-1 个数中找出次小的数，将它与第二个数交换，结果最小的数被安排在第二个元素位置上；
重复上述过程，共经过 n-1 趟排序后，排序结束。
*/
  
for (i = 0; i < n - 1; i++) {
  for (j = i + 1; j < n; j++) {
    if (ary[i] > ary[j]) {
      temp = ary[i]; // 这里 ary[i]就是关键字
      ary[i] = ary[j];
      ary[j] = temp;
    }
  }

```

## 二叉树

### 基本概念

> 在二叉树中，每个节点最多有两个子节点，一般被称为左子节点和右子节点，并且二叉树的子树有左右之分，其次序不能任意颠倒。

### 二叉树的遍历

>  最常见的树的遍历有 3 种，前序、中序和后序遍历，3 种写法相似，无非是递归的顺序略有不同。

```swift
// 用栈实现的前序遍历
func preorderTraversal(root: TreeNode?) -> [Int] {
  var res = [Int]()
  var stack = [TreeNode]()
  var node = root
    
   while !stack.isEmpty || node != nil {
     if node != nil {
       res.append(node!.val)
       stack.append(node!)
			 node = node!.left
     } else {
       node = stack.removeLast().right
     }
   }
  return res
}
```

## 搜索

### 二分查找

> 1. 先决条件：必须是一维顺序数组；
> 2. 原理： 取中，比较；
> 3. 设置最小索引和最大索引，定一个 while 循环语句条件时最小索引 < 最大索引,首先判断要查找的值不等于这 2 个索引对应的值，等于就查找成功了。不等于再定义一个中间索引，判断要查找的值是否等于中间索引值，等于就是查找成功了。不等于就判断要查找的值是否小雨中间索引对应的值，小于的话就把中间索引值减 1 赋值给最大索引，反之就把索引加 1，赋值给最小索引。

> 设置数组 r 最小索引 low，最大索引 high，求数组的中间索引 mid = (low + high) / 2;
>
> 若 r[mid] == k，查找成功；
>
> 若 r[mid] > k, 设置 high = mid - 1，继续进行二分查找；
>
> 若 r[mid] < k,设置 low = mid + 1，继续进行二分查找。





# 经验问题总结

## 程序出现了闪退，该如何解决

> 1. 单步断点调试，找出内存泄漏的地方
> 2. 全局断点调试，锁定闪退地方，找出原因
> 3. 使用僵尸变量，根据打印日志，分析原因
> 4. 分段调试，找到内存泄漏的地方
> 5. 使用 Instrument 当中的 Leak 检测工具

## 如何防止反编译

> 1. 本地数据加密：对 NSUerDefaults、sqlite 存储文件数据加密
> 2. URL 编码加密：网络请求中的 URL 进行编码加密
> 3. 网络传输数据加密：客户端传输数据提供加密方案，防止通过往里接口拦截数据
> 4. 方法体、方法名 混淆：保证源码被逆向后无法解析代码
> 5. 程序结构混排：对程序的逻辑结构进行打乱混排，降低源码的可读性

## lldb 常用的控制台命令

> 1. p： 输出基本类型，打印命令，需要指定类型，是 print 的简写。（p (int)[[[self view] subviews] count]）
> 2. po：打印对象，会调用对象 description 方法，是 print-object 的简写
> 3. expr 可以在调试时动态执行指定表达式，并将结果打印出来，常用余载调试过程中修改变量的值
> 4. bt：打印堆栈
> 5. br：breakpoint list 的简写

## 关于无痕埋点

> 利用 Runtime 交换 viewDidLoad 方法，在自定义的方法中记录用户浏览的页面信息；交换 viewWillAppear 和 viewDisAppear 方法，统计用户浏览页面的时长；
>
> 大多数 UI 控件都是基于 UIControl，拦截 se ndAction:to:forEvent: 方法，统计到某一按钮的点击；
>
> 
>
> 埋点数据可以临时保存在本地，当达到某一个数量节点时，统一提交到服务器。

## 简单介绍下 APNS 发送消息的机制

> 1. 应用在通知中注册，有 iOS 系统向 APNS 请求返回设备的令牌(device Token)
> 2. 应用程序接收到设备令牌并发送给自己的后台服务器
> 3. 服务器把需要推送的内容和设备发送给 APNS
> 4. APNS 根据设备的令牌找到设备，再由 iOS 根据 APPID 把推送内容展示。

## WKWebView 离线缓存功能

> `WKURLSchemeHandler`是`iOS11`引入的新特性，可以通过此 API 来拦截`H5`的网络请求，在请求之前判断本地是否下载过 H5 的缓存文件。
>
> 需要手动同步 cookie。

## webView 与原生交互遇到的问题

> 1. web 页面存在多级跳转，但是原生返回按钮会返回上一界面。需要判断 web 是否可以 goback
> 2. web 页面跳转二级页面后，原生无法收到 JS 回调

## WKWebView白板问题？

> 1. URL 为空
> 2. 未配置支持 http 请求，加载一个 http 页面
> 3. 占用内存过大

## 怎么解决 NSTimer 对象循环引用

> 创建 NSTimer 分类或者引入代理类

## NSTimer 和 CADisplaylink 的区别

> CADisplaylink 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器，创建一个 CADisplaylink 对象，把它添加到一个 runloop 中，并给他提供一个 target 和 selector 在屏幕刷新时调用；
>
> iOS 设备的屏幕刷新频率时固定的，CADisplaylink 在正常情况下会在每次刷新结束后都被调用，精确度高；
>
> NSTimer 的精确度比 CADisplaylink 低，runloop 在阻塞时，会推迟 NSTimer 的触发。

## 多个 cell 中的时间倒计时，怎么实现比较好

> 创建一个计时器，tableView 中可见的 cell 的计时数据都使用这个计时器进行计算

## 是否接触过反射机制？简单介绍一下

> * class 反射
>   1. 通过类名的字符串形式实例化对象:Class class= NSClassFromString(@"student");
>   2. 将类名变为字符串:NSString *className = NSStringFromClass(class);
> * SEL 反射
>   1. 通过字符串形式实例化方法：SEL selector = NSSelectorFromString(@"setName");
>   2. 将方法变成字符串:NSStringFromSelector:(@selector*(setName)) 

## iOS 中程序的五种状态

> Not Running：未运行
>
> Inactive：前台非活跃状态，处于前台，但是不能接受事件处理
>
> Active：前台活跃状态，处于前台，能接受事件处理
>
> Background：后台状态，进入后台，如果可以执行代码，会在代码执行完毕后，程序挂起
>
> Suspended：挂起状态，进入后台，不能执行代码，如果内存不足，会被杀死

## 一般有哪些容错处理

> 开发中对数据的处理，容易产生崩溃，比如 字典、数组、野指针、NSNull
>
> 1. 使用 category 给类添加方法替换掉原本存在崩溃风险的方法
> 2. 利用 runtime 方法交换技术，将系统方法替换成类新添加的方法
> 3. 利用异常的捕获防治程序崩溃，并进行相应的处理

## 一个APP如何检测手机中另一个APP的存在

> 使用 [UIApplication sharedApplication] canOpenURL 这个方式，不过需要提前知晓对应 app 的 scheme

## 向 App Store 提交时有哪些原因可能被拒

> * 崩溃
> * 第三方应用
> * 版权
> * 材料不全

# Flutter 基础

## hot reload 和 hot restart 的区别

> hot reload：在立刻更新 UI 的同时保持程序的状态，相比一下 hot restart 需要花费更长一点的时间，因为它会在更新 UI 之前将程序的状态置为初始状态。两者都比完全重新启动要快。

## StatelessWidget 和 StateFulWidget 的区别

> * StatelessWidget：当某个组件在显示期间不需要改变，或者说没有状态时使用。
> * StateFulWidget：它和一个 state 对象关联，该对象允许每次通过调用 setSate() 时，使用新值重建这个 widget，当 UI 需要动态改变时使用。

## WidgetsApp 和 MaterialApp 的区别

> * WidgetsApp：提供了基础的导航能力，和 widgets 库一起，包含了很多 Flutter 使用的基础 widget；
>
> * MaterialApp：与之相应的是 material 库，可以在任何平台或者设备上为应用提供统一外观。
>
>   也可以使用 CupertinoApp 构建 iOS 风格的应用程序

## 可以嵌套使用 Scaffold 吗

> 可以
>
> Scaffold 也是一个 widget，可以把它放在任何 widget 可以放置的地方。通过嵌套 Scaffold 可以对抽屉、卡片、底页进行分层。

## 怎么减少 widget 重建

> * 将大的 widget 树重构成较小的单个 widget，每一个 widget 都有它自己的 build 方法
> * 尽可能的使用 const 构造函数。将告知 Flutter 不需要重建这个 widget
> * 使 statefulwidget 的子树尽可能的小

## 什么是 BuildContent

> BuildContent 实际上是 Element 树中的 widget 的元素，因此每个 widget 都有其自己的 BuildContent。
>
> 通常使用 BuldContent 来获取主题或者另一个 widget 的引用。

## 怎么和原生交互

> * method invocation：数据 Dart 侧进行序列化，然后将数据发送到原生侧，可以在原生侧编写代码响应交互，然后回传序列化后到数据。
> * BasicMessageChannel：用于传递字符串和半结构化的信息，持续通信，收到消息后可以回复此消息，比如原生将遍历的文件信息陆续传递给 Dart
> * event channel：可以用来从原生发送 stream 数据到 flutter侧，对监控传感器的场景很有用。





# 简历相关问题

## RAC

### RAC 常见类

#### **RACSiganl**

> 信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。

> * RACEmptySignal：空信号，用来实现 RACSignal 的 +empty 方法；
> * RACReturnSignal：一元信号，用来实现 RACSignal 的 +return: 方法；
> * RACDynamicSignal：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例；
> * RACErrorSignal：错误信号，用来实现 RACSignal 的 +error: 方法；
> * RACChannelTerminal：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。

> 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅。

#### **RACSubscriber**

> 订阅者的意思，用于发送信号，这是一个协议

#### **RACDisposable**

> 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。

#### **RACSubject**

> 信号提供者，自己可以充当信号，又能发送信号 使用场景:通常用来代替代理

#### **RACCommand**

> RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中。

> 使用场景:监听按钮点击，网络请求。

### RAC 常用宏

#### **RAC(TARGET, [KEYPATH, [NIL_VALUE]])**

> 用于给某个对象的某个属性绑定。 

```objc
// 只要文本框文字改变，就会修改label的文字
RAC(self.labelView,text) = _textField.rac_textSignal;
```

#### **RACObserve(self, name)**

> 监听某个对象的某个属性,返回的是信号。

```objc
[RACObserve(self.view, center) subscribeNext:^(id x) {
	NSLog(@”%@”,x);
}];
```

####  **@weakify(Obj)和@strongify(Obj)**

> 1. 一般两个都是配套使用,在主头文件(ReactiveCocoa.h)中并没有导入，需要自己手动导入，RACEXTScope.h才可以使用。但是每次导入都非常麻烦，只需要在主头文件自己导入就好了。

#### **RACTuplePack**

> 把数据包装成RACTuple（元组类）

```objc
// 把参数中的数据包装成元组
RACTuple *tuple = RACTuplePack(@,@);
```

#### **RACTupleUnpack**

> 把RACTuple（元组类）解包成对应的数据。

```objc
// 把参数中的数据包装成元组
RACTuple *tuple = RACTuplePack(@”xmg”,@);
// 解包元组，会把元组的值，按顺序给参数里面的变量赋值
// name = @”xmg” age = @20
RACTupleUnpack(NSString *name,NSNumber *age) = tuple;
```

### RAC 常见用法

#### rac_signalForSelector

> 用于替代代理。

#### rac_valuesAndChangesForKeyPath

> 代替KVO，用于监听某个对象的属性改变

#### rac_signalForControlEvents

> 用于监听某个事件

#### rac_addObserverForName

> 用于监听某个通知

#### rac_textSignal

> 监听文本框文字改变

### RAC 常见方法

#### Map、flattenMap

> * Map：把源信号的值映射成一个新的值
> * flattenMap：把源信号的内容映射成一个新的信号，信号可以是任意类型

**FlatternMap 和 Map的区别**

>1.FlatternMap 中的 Block 返回信号。
>2.Map 中的 Block 返回对象。
>3.开发中，如果信号发出的值不是信号，映射一般使用 Map
>4.开发中，如果信号发出的值是信号，映射一般使用 FlatternMap

#### then、merge、combineLatest

> * then：用于连接两个信号，当第一个信号完成，才会连接then返回的信号
> * merge：把多个信号合并为一个信号，任何一个信号有新值的时候就会调用
> * combineLatest：将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号

#### filter、ignore、distinctUntilChanged、take、takeLast、takeUntil、skip

> * filter：过滤，每次信号发出，会先执行过滤条件判断
> * ignore：内部调用filter过滤，忽略掉ignore的值
> * distinctUntilChanged：当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉
> * take：从开始一共取N次的信号
> * takeLast：取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号
> * takeUntil：获取信号直到某个信号执行完成
> * skip：跳过几个信号,不接受

### RACSubject 和 RACSignal 的区别

> RACSubject 会持有订阅者（因为 RACSubject 是热信号，为了保证未来有事件发送的时候，订阅者可以收到信息，所以需要对订阅者保持状态，做法就是持有订阅者），而 RACSignal 不会持有订阅者。



## CTMediator 组件化

> 组件化是需要循序渐进地实施的。尤其是一些已经比较成熟的项目，业务会非常多，一时半会儿是不可能完全组件化的。CTMediator方案在实施过程中，对主工程业务的影响程度极小，而且是能够支持循序渐进地改造方式。

### 调用方式

> 本地组件A在某处调用`[[CTMediator sharedInstance] performTarget:targetName action:actionName params:@{...}]`向`CTMediator`发起跨组件调用，`CTMediator`根据获得的target和action信息，通过objective-C的runtime转化生成target实例以及对应的action选择子，然后最终调用到目标业务提供的逻辑，完成需求

> 远程应用通过openURL的方式，由iOS系统根据info.plist里的scheme配置找到可以响应URL的应用，应用通过`AppDelegate`接收到URL之后，调用`CTMediator`的`openUrl:`方法将接收到的URL信息传入。当然，`CTMediator`也可以用`openUrl:options:`的方式顺便把随之而来的option也接收，这取决于你本地业务执行逻辑时的充要条件是否包含option数据。传入URL之后，`CTMediator`通过解析URL，将请求路由到对应的target和action，随后的过程就变成了上面说过的本地应用调用的过程了，最终完成响应

### 仅通过 Action 暴露可调用接口

> 通过组件自带的Target-Action来响应，也就是说，模块与模块之间的接口被固化在了Target-Action这一层，避免了实施组件化的改造过程中，对Business的侵入，同时也提高了组件化接口的可维护性

### 复杂参数和非常规参数，以及组件化相关设计思路

> `复杂参数`是指由`普通类型`的数据组成的多层级参数。在本文中，我们定义只要是能够被json解析的类型就都是`普通类型`，包括NSNumber， NSString， NSArray， NSDictionary，以及相关衍生类型，比如来自系统的NSMutableArray或者你自己定义的都算。
>
> 
>
> `非常规参数`是指由`普通类型`以外的类型组成的参数，例如UIImage等这些不能够被json解析的类型。然后这些类型组成的参数在文中就被定义为`非常规参数`。

### 去 model 设计

> 组件间调用时，是需要针对参数做去 model 化的。如果组件间调用不对参数做去model化的设计，就会导致业务形式上被组件化了，实质上依然没有被独立。

> 在这种跨模块场景中，参数最好还是以去 model 化的方式去传递，在 iOS 的开发中，就是以字典的方式去传递。这样就能够做到只有调用方依赖 mediator，而响应方不需要依赖 mediator。然而在去 model 化的实践中，由于这种方式自由度太大，我们至少需要保证调用方生成的参数能够被响应方理解，然而在组件化场景中，限制去 model 化方案的自由度的手段，相比于网络层和持久层更加容易得多。

> 限制手段：参数不对就无法调用！无法调用时直接debug就能很快找到原因。

### 使用 category

> mediator 这个 repo 维护了若干个针对 mediator 的 category，每一个对应一个 target，每个 category 里的方法对应了这个 target 下所有可能的调用场景，这样调用者在包含 mediator 的时候，自动获得了所有可用的 target-action，无论是调用还是参数传递，都非常方便。

> - category 本身就是一种组合模式，根据不同的分类提供不同的方法，此时每一个组件就是一个分类，因此把每个组件可以支持的调用用 category 封装是很合理的。
> - 在 category 的方法中可以做到参数的验证，在架构中对于保证参数安全是很有必要的。当参数不对时，category 就提供了补救的入口。
> - category 可以很轻松地做请求转发，如果不采用 category，请求转发逻辑就非常难做了。
> - category 统一了所有的组件间调用入口，因此无论是在调试还是源码阅读上，都为工程师提供了极大的方便。
> - 由于 category 统一了所有的调用入口，使得在跨模块调用时，对于 param 的 hardcode 在整个App中的作用域仅存在于 category 中，在这种场景下的 hardcode 就已经变成和调用宏或者调用声明没有任何区别了，因此是可以接受的。

### CTMediator 的缺点

> 1. 因为利用了 Runtime 反射，本地 Target 和 Action 的命名必须规范
> 2. 如果各个组件是 pod 静态库的方式引用，在多人同时开发多个 pod 时，要注意相互之间的依赖

## Jenkins

### 基本使用和注意事项

>  安装步骤可参考 [Jenkins 使用(https://blog.dongjiawang.top)](https://blog.dongjiawang.top/2021/03/20/2021-02-20-Jenkins%20使用/)

**遇到的问题**

> * 因为 苹果 M1 芯片的原因，新服务器（Mac mini）暂不支持 SVN 服务
> * 通过 brew 升级 Jenkins 后，需要重新配置一下 IP 信息(homebrew.mxcl.jenkins.plist 文件中的 httpListenAddress 参数为 0.0.0.0 或本机 IP)
> * 尽量使用 homebrew 安装，从官网下载安装包会默认安装在 shared 目录，之后会遇到访问权限的问题
> * 在编写 shell 脚本文件时，打出来的包最好放在 Jenkins 当前 workspace 的文件夹，否则容易遇到访问权限的问题

> 配置 GitLab 的 webhook URL，可以添加关键字过滤，每当 commit 中有对应的关键字，会触发 Jenkins 自动化打包

### 迁移 git 库

> 1. 使用 git clone -bare 命令克隆一份裸版本库
>
> 2. 在 git 上的新目录创建空项目
> 3. 使用 git push --mirror 命令推送到新地址，会保留所有的提交记录

## WKWebView

### cookie 同步

> WKProcesspool 的方式共享 webView 进程池的方式共享 cookie

> 在清理 cookie 缓存的时候也要记得清理一下这个 processPool。

### WebViewJavascriptBridge

> 连接 JS 和 iOS 原生交互的开源框架，通过 webview 的代理拦截 scheme，然后注入相应的 JS。

> 如果注入的 JS 函数体有任何错误，都不会有打印日志，也不会有任何回调。
